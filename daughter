#!/usr/bin/env python3

from contextlib import contextmanager
import requests
import subprocess
import os
import sys
import string

INDENTATION = '  '
USER_HOME = os.path.expanduser('~')
USER_CODE_DIRECTORY = os.path.join(USER_HOME, 'code')
DATA_DIRECTORY = 'data'
DOWNLOAD_DIRECTORY = 'downloads'
DOWNLOAD_CHUNK_SIZE = 256
PIP_FILENAME = 'pip.txt'
PACKAGES_FILENAME = 'packages.txt'

CURRENT_JETBRAINS_VERSION = "2018.2.4"

IDEA_LINK = "https://download.jetbrains.com/idea/ideaIU-{}.tar.gz"
CLION_LINK = "https://download.jetbrains.com/cpp/CLion-{}.tar.gz"
PYCHARM_LINK = "https://download.jetbrains.com/python/pycharm-professional-{}.tar.gz"
DATAGRIP_LINK = "https://download.jetbrains.com/datagrip/datagrip-{}.tar.gz"
JETBRAINS_LINKS = [IDEA_LINK, CLION_LINK, PYCHARM_LINK, DATAGRIP_LINK]


class Sentence:
    def __init__(self, words):
        self.words = words

    def starts_with(self, sentence):
        if len(sentence.words) > len(self.words):
            return False
        return self.words[:len(sentence.words)] == sentence.words

    def remove_prefix(self, sentence):
        assert self.starts_with(sentence)
        return Sentence([self.words[len(sentence.words):]])

    def __str__(self) -> str:
        return ' '.join(self.words)


class Command:
    def __init__(self, wording: str, action):
        self.invocation = Sentence(wording.split())
        self.action = action

    def matches(self, request: Sentence) -> bool:
        return request.starts_with(self.invocation)

    def answer(self, request: Sentence):
        self.action(request.remove_prefix(self.invocation))

    def __str__(self) -> str:
        return str(self.invocation)


@contextmanager
def change_directory(new_directory):
    previous_directory = os.getcwd()
    os.chdir(os.path.expanduser(new_directory))
    try:
        yield
    finally:
        os.chdir(previous_directory)


def not_implemented(sentece: Sentence):
    raise NotImplementedError()


def assert_is_path_friendly(entry: str):
    valid_path_characters = string.ascii_lowercase + string.ascii_uppercase + '-'
    for char in entry:
        assert char in valid_path_characters


def get_housekeeper_directory():
    return os.path.dirname(sys.argv[0])


def get_path_to_housekeeper_data_file(filename):
    return os.path.join(get_housekeeper_directory(), DATA_DIRECTORY, filename)


def download(link, filename):
    r = requests.get(link, stream=True)
    with open(filename, 'wb') as fd:
        for chunk in r.iter_content(chunk_size=DOWNLOAD_CHUNK_SIZE):
            fd.write(chunk)


def install_jetbrains_products():
    for link in JETBRAINS_LINKS:
        download(link, os.path.join(DOWNLOAD_DIRECTORY, os.path.basename(link)))


def list_repositories(sentece: Sentence):
    dirty = []
    clean = []
    for basename in sorted(os.listdir(path=USER_CODE_DIRECTORY)):
        assert_is_path_friendly(basename)
        full_path = os.path.join(USER_CODE_DIRECTORY, basename)
        with change_directory(full_path):
            command = 'git status --short'
            output = subprocess.check_output(command.split())
        if output:
            dirty.append(basename)
        else:
            clean.append(basename)
    print('Found {} repositories.'.format(len(dirty) + len(clean)))
    if dirty:
        print('Dirty:')
        for repository in dirty:
            print('{}{}'.format(INDENTATION, repository))
    if clean:
        print('Clean:')
        for repository in clean:
            print('{}{}'.format(INDENTATION, repository))


def install_operating_system_packages():
    with open(get_path_to_housekeeper_data_file(PACKAGES_FILENAME)) as packages_file:
        packages = [line.strip() for line in packages_file.readlines()]
    command = 'sudo zypper in' + ' ' + ' '.join(packages)
    print(command)
    subprocess.call(command.split())


def install_python_packages():
    command = 'pip install --user -r ' + get_path_to_housekeeper_data_file(PIP_FILENAME)
    print(command)
    subprocess.call(command.split())


def install_packages(sentence: Sentence):
    install_operating_system_packages()
    install_python_packages()


def get_package_list():
    with open(get_path_to_housekeeper_data_file(PACKAGES_FILENAME)) as packages_file:
        packages = [line.strip() for line in packages_file.readlines()]
    return packages


def set_package_list(package_list: [str]):
    # TODO: use a temporary file.
    with open(get_path_to_housekeeper_data_file(PACKAGES_FILENAME), 'w') as packages_file:
        print('\n'.join(package_list), file=packages_file)


def add_package(sentence: Sentence):
    packages = get_package_list()
    packages = list(set(packages))
    packages.sort()
    set_package_list(packages)


def list_packages(sentence: Sentence):
    print('\n'.join(get_package_list()))


def get_commands():
    return [Command('list commands', print_commands),
            Command('analyze repositories', list_repositories),
            Command('add package', add_package),
            Command('list packages', list_packages),
            Command('install packages', install_packages),
            ]


def print_commands(sentence: Sentence):
    for command in get_commands():
        print(command)


def main():
    if len(sys.argv) < 2:
        print("Use {} [REQUEST]".format(os.path.basename(sys.argv[0])))
        return
    request = Sentence(sys.argv[1:])
    for command in get_commands():
        if command.matches(request):
            command.answer(request)
            return
    print('Not a valid command.')


if __name__ == '__main__':
    main()
